---
title: "Delay distributions"
---

```{r echo = FALSE}
set.seed(123)
```

# Objectives

The aim of this session is for you to familiarise yourself with the concept of delay distributions and their use in describing epidemiological processes.
You will do this by working in `R` with epidemiological time series that are linked via delay distributions.

# Simulating delayed epidemiological data

First, load and plot the data

```{r}
library("nfiidd")
library("ggplot2")
library("tidyr")

data(infection_times)
head(infection_times)

ggplot(infection_times, aes(x = infection_time)) +
  geom_histogram() +
  xlab("Infection time (in days)") +
  ylab("Number of infections")
```

Next, simulate delay

```r
library("dplyr")
start_date <- as.Date("2024-05-10")
inf_hosp <- infection_times |>
  mutate(
    incubation_period = rgamma(n(), shape = 5, rate = 1),
    onset_to_hosp = rlnorm(n(), meanlog = 1, sdlog = 1),
    infection_date = start_date + infection_time,
    onset_date = start_date + infection_time + incubation_period,
    hosp_date =
      start_date + infection_time + incubation_period + onset_to_hosp
  )
```

Next, plot onsets

```r
ggplot(inf_hosp, aes(x = hosp_date)) +
  geom_histogram() +
  xlab("Onset date") +
  ylab("Number of symptom onsets")
```

Or maybe plot both

```r
df <- inf_hosp |>
  pivot_longer(cols = c(infection_date, onset_date, hosp_date), names_to = "type", values_to = "date")
ggplot(df, aes(x = date)) +
  geom_histogram(position = "dodge") +
  facet_wrap(~ type, ncol = 1) +
  xlab("Date") +
  ylab("Count")
```

Not everybody with symptoms gets hospitalised.
Need to scale

```r
hosp_scaled <- inf_hosp |>
  mutate(hosp_date = if_else(rbinom(n = n(), size = 1, p = 0.3) == 1, hosp_date, as.Date(NA_character_)))
df <- hosp_scaled |>
  pivot_longer(cols = c(infection_date, onset_date, hosp_date), names_to = "type", values_to = "date")
ggplot(df, aes(x = date)) +
  geom_histogram(position = "dodge") +
  facet_wrap(~ type, ncol = 1) +
  xlab("Date") +
  ylab("Count")
```

# Estimating delay distributions

Provide data set that is the result of the operations above, but only with dates.

```r
## temporary: to be replaced with data set that has the dates in it
hosp_scaled <- hosp_scaled |>
  mutate(
    incubation_period = as.integer(onset_date - infection_date), 
    onset_to_hosp = as.integer(hosp_date - onset_date)
  )
```

now go backwards?
naive(ish) approach: find the distribution that matches what is happening

```r
delay_model <- '
  data {
    int n;
    array[n] real onset_to_hosp;
  }

  parameters {
     real meanlog;
     real<lower = 0> sdlog;
  }

  model {
    // priors
    meanlog ~ normal(0, 10);
    sdlog ~ normal(0, 10) T[0, ];

    // likelihood
    onset_to_hosp ~ lognormal(meanlog, sdlog);
  }
'

model <- stan_model(model_code = delay_model)

sampling(
  model,
  data = list(
    n = nrow(na.omit(hosp_scaled)),
    onset_to_hosp = na.omit(hosp_scaled)$onset_to_hosp
  )
)
```

This will cause an error - why? (answer: zeroes; would be nice to have a better error message stan)

How to fix? Add 1? Add 0.5? The latter works quite well - why?

# Accounting for censoring

A better way to account for censoring is to integrate over a window:

```r
delay_model_discrete <- '
  data {
    int n;
    array[n] real onset_to_hosp;
  }

  transformed data {
    array[n] real onset_to_hosp_upper;
    array[n] real onset_to_hosp_lower;

    for (i in 1:n) {
      onset_to_hosp_upper[i] = onset_to_hosp[i] + 1;
      onset_to_hosp_lower[i] = onset_to_hosp[i] - 1;
    }
  }

  parameters {
     real meanlog;
     real<lower = 0> sdlog;
  }

  model {
    // priors
    meanlog ~ normal(0, 10);
    sdlog ~ normal(0, 10);

    // likelihood
    for (i in 1:n) {
      if (onset_to_hosp_lower[i] > 0) {
        target += log_diff_exp(
          lognormal_lcdf(onset_to_hosp_upper[i] | meanlog, sdlog),
          lognormal_lcdf(onset_to_hosp_lower[i] | meanlog, sdlog)
        );
      } else {
        target += lognormal_lcdf(onset_to_hosp_upper[i] | meanlog, sdlog);
      }
    }
  }

'

model_discrete <- stan_model(model_code = delay_model_discrete)
sampling(
  model_discrete,
  data = list(
    n = nrow(na.omit(hosp_scaled)),
    onset_to_hosp = na.omit(hosp_scaled)$onset_to_hosp
  )
)
```

Better? How could it be made even better?

# Real-time estimation and right-truncation

- try the approach from before -- oops! What has gone wrong?
- implement truncation
- we have estimated a delay - hey, we can do nowcating!
