---
title: "Forecasting concepts"
order: 7
---

```{r echo = FALSE}
set.seed(123)
```

# Objectives

The aim of this session is to introduce the concept of forecasting, using a simple model, and forecasting evaluation.

# Libraries used

In this session we will use the `nfidd` package to load the data set of infection times, the `dplyr` and `tidyr` packages for data wrangling, `ggplot2` library for plotting, the `here` library to find the stan model, and the `cmdstanr` library for using stan. A new addition is the `scoringutils` package for calculating forecast evaluation metrics.
We will also use the `tidybayes` package for extracting results of the inference.

```{r libraries, message = FALSE}
library("nfidd")
library("dplyr")
library("tidyr")
library("ggplot2")
library("here")
library("cmdstanr")
library("tidybayes")
library("scoringutils")
```

::: {.callout-tip}
The code in this session can be run as an interactive notebook using RStudio, or copied-and-pasted into an R session.
It needs to be run inside the course repository so that the `here()` commands below find the stan model files.
:::

# Introduction to forecasting as an epidemiological problem, and its relationship with nowcasting and R estimation

See the lecture slides.

# What is forecasting?

Forecasting is the process of making predictions about the future based on past and present data.
In the context of infectious disease epidemiology, forecasting is the process of predicting the future course of an epidemic based on past and present data.
Here we focus on forecasting observed data (i.e. onsets) but forecasts can also be made for other quantities of interest such as the number of infections, the reproduction number, or the number of deaths.
Epidemiological forecasting is closely related to nowcasting and, when using mechanistic approaches, estimation of the reproduction number. In fact, the model we will use for forecasting is the same as the model we used for nowcasting and estimation of the reproduction number. The only difference is that we will extend the model into the future and for the purpose of this session we will remove the nowcasting part of the model.

::: {.callout-tip}
## What do we look for in a good forecast? Some food for thought:
1. **Calibration**: The forecast should be well calibrated. This means that the forecasted probabilities should match the observed frequencies. For example, if the model predicts a 50% probability of an event occurring, then the event should occur approximately 50% of the time.
2. **Unbiasedness**: The forecast should be unbiased. This means that the average forecasted value should be equal to the average observed value. It shouldn't consistently over or under predict.
3. **Accuracy**: The forecast should be accurate. This means that the forecasted values should be close to the observed values.
:::

# Extending a model into the future

The model we introduced in the [renewal session](R-estimation-and-the-renewal-equation.qmd) the reproduction number using a random walk, then used a discrete renewal process to model the number of infections, and convolved these with a delay distribution to model the number of onsets with Poisson observation error.
Based on what we found in the [nowcasting session](nowcasting.qmd) this seems like a reasonable model for the data and so we might want to use it to forecast into the future.
We can do this by extending the model into the future by simulating the model forward in time. 
This is known as a generative model.
We actually already introduced a model that could do this in the renewal session (remember `h` from the data list in the renewal session?).
So what does this look like in code? Lets load in the model again and take a look.

```{r load_model}
mod <- cmdstan_model(here("stan", "estimate-inf-and-r-rw.stan"))
mod$print(line_numbers = TRUE)
```

::: .callout-tip
## Take 5 minutes
What have we changed in the model to make it a forecasting model?
Do you see any limitations of this approach?
:::

::: {.callout-note collapse="true"}
## Solution
- What have we changed in the model to make it a forecasting model?
  - Added the `h` parameter to the data list to specify the number of days to forecast into the future.
  - Added the `m` parameter as a piece of transformed data that is the total number of days to include in the model (i.e. the number of days in the data plus the number of days to forecast).
  - `m` is then used in all arrays in the model rather than `n`. This means that `rw_noise` is now `m-1` long, and  `R`, `onsets`, `infections` and `onsets` are `m` long.
  - As there are only `n` observations in the data in the likelihood we only use the first `n` elements of `onsets`.
  - To include observation error in the forecast a `generated quantities` block has been added which takes the last `h` onsets as the mean of a Poisson distribution and samples from this distribution to get the forecasted onsets.
- Do you see any limitations of this approach?
  - Including `h` in the `parameters` and `model` blocks increases the number of parameters and amount of work we have to do when fitting the model.
  It would be more computationally efficient to have a separate model for forecasting.
:::

Before we can forecast we need some data to fit the model to and the compare the forecasts to. We will use the same simulated data as in the renewal and nowcasting sessions. We also need to pick a point to forecast from. We will use day 41 in line with the nowcasting session.

```{r, load-simulated-onset}
source(here::here("snippets", "simulate-onsets.r"))
onset_df

cutoff <- 41

filtered_onset_df <- onset_df |>
  filter(day <= cutoff)
```

## Fitting the model and forecast for 28 days into the future

We can now fit the model to the data and then forecast into the future. This should look very similar to the code we used in the renewal session but with the addition of a non-zero `h` in the data list.

```{r fit_model}
horizon <- 28

data <- list(
  n =nrow(filtered_onset_df),
  I0 = 1,
  obs = filtered_onset_df$onsets,
  gen_time_max = length(gen_time_pmf),
  gen_time_pmf = gen_time_pmf,
  ip_max = length(ip_pmf) - 1,
  ip_pmf = ip_pmf,
  h = horizon # Here we set the number of days to forecast into the future
)
rw_forecast <- mod$sample(
  data = data, parallel_chains = 4, refresh = 0, show_exceptions = FALSE, show_messages = FALSE, adapt_delta = 0.95)
rw_forecast
```

## Visualising the forecast

We can now visualise the forecast. We will first extract the forecast and then plot the forecasted onsets alongside the observed onsets.

```{r extract-forecast}
forecast <- rw_forecast |>
  gather_draws(forecast[day]) |>
  mutate(day = day + cutoff)

target_onsets <- onset_df |>
  filter(day > cutoff) |>
  filter(day <= cutoff + horizon)
```

```{r plot_forecast}
forecast |>
  filter(.draw <= 100) |>
  ggplot(aes(x = day)) +
  geom_line(alpha = 0.1, aes(y = .value, group = .draw)) +
  geom_point(data = target_onsets, aes(x = day, y = onsets), color = "black")
```

::: {.callout-tip}
## Take 5 minutes
What do you think of this forecast?
Did the model do a good job?
Is there another way you could visualise the forecast that might be more informative?
:::

::: {.callout-note collapse="true"}
## Solution
- On the face of it the forecast looks very poor with some very high predictions compared to the data.
- Based on this visualisation it is hard to tell if the model is doing a good job but it seems like it is not.
- As outbreaks are generally considered to be exponential processes it might be more informative to plot the forecast on the log scale.

```{r plot_forecast_log}
forecast |>
  filter(.draw <= 100) |>
  ggplot(aes(x = day)) +
  geom_line(alpha = 0.1, aes(y = .value, group = .draw)) +
  geom_point(data = target_onsets, aes(x = day, y = onsets), color = "black") +
  scale_y_continuous(trans = "log")
```

This should be a lot more informative. We see that for longer forecast horizons the model is not doing a great job of capturing the reduction in onsets. However, we can now  see that the model seems to be producing very reasonable forecasts for the first week or so of the forecast. This is a common pattern in forecasting where the model is good at capturing the short term dynamics but struggles with the longer term dynamics.
:::

As our forecasting model is based on the effective reproduction number we can also visualise the forecast of the reproduction number. This can be helpful for understanding why our forecasts of onsets look the way they do and for understanding the uncertainty in the forecasts. To get an even better picture here we will fit another model to a longer time series and then compare the forecast and estimated reproduction numbers.

```{r fit_model_long}
long_onset_df <- onset_df |>
  filter(day <= cutoff + horizon)

long_data <- list(
  n =nrow(long_onset_df),
  I0 = 1,
  obs = long_onset_df$onsets,
  gen_time_max = length(gen_time_pmf),
  gen_time_pmf = gen_time_pmf,
  ip_max = length(ip_pmf) - 1,
  ip_pmf = ip_pmf,
  h = 0
)

rw_long <- mod$sample(
  data = long_data, parallel_chains = 4, refresh = 0, show_exceptions = FALSE, show_messages = FALSE, adapt_delta = 0.95)
```

We first need to extract the forecast and estimated reproduction numbers.

```{r extract-Rt}
forecast_r <- rw_forecast |>
  gather_draws(R[day]) |>
  mutate(type = "forecast")

long_r <- rw_long |>
  gather_draws(R[day]) |>
  mutate(type = "estimate")
```

We can now plot the forecast and estimated reproduction numbers.

```{r plot-Rt}
forecast_r |>
  bind_rows(long_r) |>
  filter(.draw <= 50) |>
  ggplot(aes(x = day)) +
  geom_vline(xintercept = cutoff, linetype = "dashed") +
  geom_hline(yintercept = 1, linetype = "dashed") +
  geom_line(aes(y = .value, group = interaction(.draw, type), color = type), alpha = 0.1)
```

::: {.callout-tip}
The horizontal dashed line at 1 represents the threshold for epidemic growth. If the reproduction number is above 1 then the epidemic is growing, if it is below 1 then the epidemic is shrinking.
:::

::: {.callout-note}
The vertical dashed line represents the point at which we started forecasting.
:::

::: {.callout-tip}
## Take 5 minutes
Can you use this plot to explain why the forecast of onsets looks the way it does?
:::

::: {.callout-note collapse="true"}
## Solution
- When both models are being fit to data (i.e before the vertical dashed line) the forecast and estimated reproduction numbers are very similar.
- For short-term forecasts R estimates continue to be fairly similar.
- However, the estimates have a consistent downwards trend which is not captured by the forecast (which looks like it has a constant mean value with increasing uncertainty).
- This explains the divergence between the forecast and the data as the horizon increases.
- It looks like only a relatively small number of forecast R trajectories grow to be very large but these are enough to visually dominate the forecast of onsets on the natural scale.
- The performance we are seeing here makes sense given that random walks are defined to have a constant mean and increasing variance.
:::

We managed to learn quite a lot about our models forecasting limitations just looking at a single forecast using visualisations. However, what if we wanted to quantify how well the model is doing? This is where forecast evaluation comes in which we will cover in the next section.

# Introduction to forecast evaluation

See the lecure notes for more information on forecast evaluation.

# Evaluate your forecast

In order to properly evaluate forecasts from this model we really need to forecast over a period of time. Ideally, capturing different epidemic dynamics. This will also give us more to work with when using scoring metrics. We will now load in some forecasts we made earlier and evaluate them.

```{r load_forecasts}
rw_forecasts
```


::: {.callout-tip}
We generated these forecasts using the code in `data-raw/generate-example-forecasts.r` which uses the same approach we just took for a single forecast date but generalises it to many forecasts dates.

Some important things to note about these forecasts:
- We used a 14 day forecast horizon.
- Each forecast used all the data up to the forecast date.
- We generated 1000 posterior samples for each forecast.
- We started forecasting 3 weeks into the outbreak and then forecast every 7 days until the end of  the data (excluding the last 14 days to allow a full forecast).
- We used pregenerated simulated data:

```{r}
example_onset_df
```

:::

## Visualising your forecast

As for a single forecast, our first step is to visualise the forecasts as this can give us a good idea of how well the model is doing without having to calculate any metrics.

```{r plot-all-forecasts}
rw_forecasts |>
  filter(.draw <= 50) |>
  ggplot(aes(x = day)) +
  geom_line(aes(y = .value, group = interaction(.draw, target_day), col = target_day), alpha = 0.1) +
  geom_point(data = example_onset_df |>
    filter(day >= 21),
    aes(x = day, y = onsets), color = "black")
```


As for the single forecast it may be helpful to also plot the forecast on the log scale.

```{r plot-all-forecasts-log}
rw_forecasts |>
  filter(.draw <= 50) |>
  ggplot(aes(x = day)) +
  geom_line(aes(y = .value, group = interaction(.draw, target_day), col = target_day), alpha = 0.1) +
  geom_point(data = example_onset_df, aes(x = day, y = onsets), color = "black") +
  scale_y_continuous(trans = "log")
```

::: {.callout-tip}
## Take 5 minutes
What do you think of these forecasts?
Are they any good?
How well do they capture changes in trend?
Does the uncertainty seem reasonable?
Do they seem to under or over predict consistently?
Would you visualise the forecast in a different way?
:::

::: {.callout-note collapse="true"}
## Solution
What do you think of these forecasts?
  - We think these forecasts are a reasonable place to start but there is definitely room for improvement.
Are they any good?
  - They seem to do a reasonable job of capturing the short term dynamics but struggle with the longer term dynamics.
How well do they capture changes in trend?
  - There is litle evidence of the model capturing the reduction in onsets before it begins to show in the data.
Does the uncertainty seem reasonable?
 - On the natural scale it looks like the model often over predicts. Things seem more balanced on the log scale but the model still seems to be overly uncertain.
Do they seem to under or over predict consistently?
  - It looks like the model is consistently over predicting on the natural scale but this is less clear on the log scale.
:::

## Scoring your forecast

On top of visualising the forecasts we can also transform them using scoring metrics to summarise performance.
Whilst some of these metrics are more useful for comparing models, many can be also be useful for understanding the performance of a single model.
We will look at some of these metrics in the next section.

We will use the [`{scoringutils}`](https://epiforecasts.io/scoringutils/dev/) package to calculate these metrics.
Our first step is to convert our forecasts into a format that the `{scoringutils}` package can use.
We will use `as_forecast` to do this:

```{r convert-forecasts}
sc_forecasts <- rw_forecasts |>
  left_join(example_onset_df, by = "day") |>
  filter(!is.na(.value)) |>
  as_forecast(
    forecast_unit = c("target_day", "horizon", "model"),
    forecast_type = "sample",
    observed = "onsets",
    predicted = ".value",
    model = "model",
    sample_id = ".draw"
  )
sc_forecasts
```

As you can see this has created a `forecast` object which has a print method that summarises the forecasts.


::: {.callout-tip}
## Take 2 minutes
What important information is in the `forecast` object?
:::

::: {.callout-note collapse="true"}
## Solution
 - The forecast unit which is the target day, horizon, and model
 - The type of forecast which is a sample forecast
:::

Everything seems to be in order. We can now use the `scoringutils` package to calculate some metrics. We will use the default sample metrics (as our forecasts are in sample format) and score our forecasts.

```{r score-forecasts}
sc_scores <- sc_forecasts |>
  score()

sc_scores
```

### At a glance

Before we look in detail at the scores, we can use `summarise_scores` to get a quick overview of the scores. Don't worry if you don't understand all the scores yet, we will go some of them in more detail in the next section and you can find more information in the [`{scoringutils}` documentation](https://epiforecasts.io/scoringutils/dev).

```{r}
sc_scores |>
  summarise_scores(by = "model")
```

::: {.callout-tip}
## Take 2 minutes
Before we look in detail at the scores, what do you think the scores are telling you?
:::

### Continuous ranked probability score

#### What is the Continuous Ranked Probability Score (CRPS)?

The Continuous Ranked Probability Score (CRPS) is a proper scoring rule used to evaluate the accuracy of probabilistic forecasts. It is a generalization of the Mean Absolute Error (MAE) to probabilistic forecasts, where the forecast is a distribution rather than a single point estimate (i.e. like ours).

::: {.callout-tip}
Proper scoring rules are scoring rules that are optimized when the forecasted distribution is equal to the true distribution. In effect, they incentivize forecasters to provide accurate and well-calibrated probabilistic forecasts.
:::

The CRPS can be thought about as the combination of two key aspects of forecasting:
1. The accuracy of the forecast in terms of how close the predicted values are to the observed value.
2. The confidence of the forecast in terms of the spread of the predicted values.

By balancing these two aspects, the CRPS provides a comprehensive measure of the quality of probabilistic forecasts.

::: {.callout-tip}
## Key things to note about the CRPS
  - Small values are better
  - As it is an absolute scoring rule it can be difficult to use to compare forecasts across scales.
:::


::: {.callout-tip, collapse="true"}
#### Mathematical Definition (optional)
For distributions with a finite first moment (a mean exists and it is finite), the CRPS can be expressed as:

$$
CRPS(D, y) = \mathbb{E}_{X \sim D}[|X - y|] - \frac{1}{2} \mathbb{E}_{X, X' \sim D}[|X - X'|]
$$

where $$ X $$ and $$ X' $$ are independent random variables sampled from the distribution $$ D $$. To calculate this we simpley replace $$ X $$ and $$ X' $ by samples from our posterior distribution and sum over all possible combinations.

This equation can be broke down into the two components:

##### Breakdown of the Components

1. **Expected Absolute Error Between Forecast and Observation**:
   $$
   \mathbb{E}_{X \sim D}[|X - y|]
   $$
   This term represents the average absolute difference between the values predicted by the forecasted distribution $$ D $$ and the actual observed value $$ y $$. It measures how far, on average, the forecasted values are from the observed value. A smaller value indicates that the forecasted distribution is closer to the observed value.

2. **Expected Absolute Error Between Two Forecasted Values**:
   $$
   \frac{1}{2} \mathbb{E}_{X, X' \sim D}[|X - X'|]
   $$
   This term represents the average absolute difference between two independent samples from the forecasted distribution $$ D $$. It measures the internal variability or spread of the forecasted distribution. A larger value indicates a wider spread of the forecasted values.

##### Interpretation

- **First Term ($$ \mathbb{E}_{X \sim D}[|X - y|] $$)**: This term penalizes the forecast based on how far the predicted values are from the observed value. It ensures that the forecast is accurate in terms of proximity to the actual observation.

- **Second Term ($$ \frac{1}{2} \mathbb{E}_{X, X' \sim D}[|X - X'|] $$)**: This term accounts for the spread of the forecasted distribution. It penalizes forecasts that are too uncertain or have a wide spread. By subtracting this term, the CRPS rewards forecasts that are not only accurate but also confident (i.e., have a narrow spread).
:::

Whilst the CRPS is a very useful metric it can be difficult to interpret in isolation. It is often useful to compare the CRPS of different models or to compare the CRPS of the same model under different conditions. For example, lets compare the CRPS across different forecast horizons.

```{r}
sc_scores |>
  summarise_scores(by = "horizon") |>
  ggplot(aes(x = horizon, y = crps)) +
  geom_point()
```

and across different forecast horizons.

```{r}
sc_scores |>
  summarise_scores(by = "target_day") |>
  ggplot(aes(x = target_day, y = crps)) +
  geom_point()
```

::: {.callout-tip}
## Take 5 minutes 
How do the CRPS scores change based on forecast date?
How do the CRPS scores change with forecast horizon?
What does this tell you about the model?
:::

::: {.callout-note collapse="true"}
## Solution
  - The CRPS scores increase for forecast dates where incidence is higher. 
  - The CRPS scores increase with forecast horizon.
  - As the CRPS is an absolute measure it is hard to immediately know if the CRPS increasing with forecast date indicates that the model is performing worse.
  - However, the CRPS increasing with forecast horizon is a sign that the model is struggling to capture the longer term dynamics of the epidemic.
:::

### PIT histograms

As well as the CRPS we can also look at the calibration and bias of the model. Calibration is the agreement between the forecast probabilities and the observed frequencies. Bias is a measure of how likely the model is to over or under predict the observed values.

There are many ways to assess calibration and bias but one common way is to use a probability integral transform (PIT) histogram. This is a histogram of the cumulative distribution of function of a forecast evaluated at the observed value.

::: {.callout-tip}
## Interpreting the PIT histogram
- Ideally PIT histograms should be uniform. 
- If is a U shape then the model is overconfident and if it is an inverted U shape then the model is underconfident. 
- If it is skewed then the model is biased towards the direction of the skew.
:::

::: {.callout-tip, collapse="true"}
## Mathematical Definition (optional)

### Continuous Case

For a continuous random variable $$ X $$ with cumulative distribution function (CDF) $$ F_X $$, the PIT is defined as:

$$ Y = F_X(X) $$

where $$ Y $$ is uniformly distributed on $$[0, 1]$$. 

#### Integer Case

When dealing with integer forecasts, the standard PIT does not yield a uniform distribution even if the forecasts are perfectly calibrated. To address this, a randomized version of the PIT is used. For an integer-valued random variable $$ X $$ with CDF $$ F_X $$, the randomized PIT is defined as:

$$ U = F_X(k) + v \cdot (F_X(k) - F_X(k-1)) $$

where:
- $$ k $$ is the observed integer value.
- $$ F_X(k) $$ is the CDF evaluated at $$ k $$.
- $$ v $$ is a random variable uniformly distributed on $$[0, 1]$$.

This transformation ensures that $$ U $$ is uniformly distributed on $$[0, 1]$$ if the forecasted distribution $$ F_X $$ is correctly specified.
:::

Let's first look at the overall PIT histogram.

```{r pit-histogram}
 sc_forecasts |>
  get_pit(by = "model") |>
  plot_pit()
```

As before lets look at the PIT histogram by forecast horizon (to save space we will only look at 1, 3, 7, and 14 days)

```{r pit-histogram-horizon}
 sc_forecasts |>
  filter(horizon %in% c(1, 3, 7, 14)) |>
  get_pit(by = "horizon") |>
  plot_pit() +
  facet_wrap(~horizon)
```

and then for different forecast dates.

```{r pit-histogram-date}
 sc_forecasts |>
  get_pit(by = "target_day") |>
  plot_pit() +
  facet_wrap(~target_day)
```

::: {.callout-tip}
## Take 5 minutes
What do you think of the PIT histograms?
Do they look well calibrated?
Do they look biased?
:::

::: {.callout-note collapse="true"}
## Solution
:::

## Scoring on the log scale

We can also score on the log scale.
This can be useful if we are interested in the relative performance of the model at different scales of the data.
For example, if we are interested in the model's performance at capturing the exponential growth phase of the epidemic.
In some sense scoring in this way can be an approximation of scoring the effective reproduction number estimates.
Doing this directly can be difficult as the effective reproduction number is a latent variable and so we cannot directly score it.

We again use `scoringutils` but first transform both the forecasts and observations to the log scale. Note that we cannot log scale after scoring as this will give incorrect results.

```{r log-convert-forecasts}
log_sc_forecasts <- sc_forecasts |>
  transform_forecasts(append = FALSE)

log_scores <- log_sc_forecasts |>
  score()
```

For more on scoring on the log scale see [Scoring forecasts on transformed scales](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1011393).

### At a glance

```{r}
log_scores |>
  summarise_scores(by = "model")
```

::: {.callout-tip}
## Take 2 minutes
Before we look in detail at the scores, what do you think the scores are telling you? How do you think they will differ from the scores on the natural scale?
:::

### CRPS

```{r}
log_sc_scores |>
  summarise_scores(by = "horizon") |>
  ggplot(aes(x = horizon, y = crps)) +
  geom_point()
```

and across different forecast horizons.

```{r}
log_sc_scores |>
  summarise_scores(by = "target_day") |>
  ggplot(aes(x = target_day, y = crps)) +
  geom_point()
```

::: {.callout-tip}
## Take 5 minutes 
How do the CRPS scores change based on forecast date?
How do the CRPS scores change with forecast horizon?
What does this tell you about the model?
:::

::: {.callout-note collapse="true"}
## Solution
:::

### PIT histograms

Let's first look at the overall PIT histogram.

```{r log-pit-histogram}
 log_sc_forecasts |>
  get_pit(by = "model") |>
  plot_pit()
```

As before lets look at the PIT histogram by forecast horizon (to save space we will only look at 1, 3, 7, and 14 days)

```{r log-pit-histogram-horizon}
 log_sc_forecasts |>
  filter(horizon %in% c(1, 3, 7, 14)) |>
  get_pit(by = "horizon") |>
  plot_pit() +
  facet_wrap(~horizon)
```

and then for different forecast dates.

```{r log-pit-histogram-date}
 log_sc_forecasts |>
  get_pit(by = "target_day") |>
  plot_pit() +
  facet_wrap(~target_day)
```

::: {.callout-tip}
## Take 5 minutes
What do you think of the PIT histograms?
Do they look well calibrated?
Do they look biased?
:::

::: {.callout-note collapse="true"}
## Solution

:::

# Going further

- What other ways could we summarise the performance of the forecasts?
- What other metrics could we use?
- There is no one-size-fits-all approach to forecast evaluation, often you will need to use a combination of metrics to understand the performance of your model  and typically the metrics you use will depend on the context of the forecast. What attributes of the forecast are most important to you?
- There are many other metrics that can be used to evaluate forecasts. The [documentation](https://epiforecasts.io/scoringutils/dev/articles/metric-details.html) for the `{scoringutils}` package has a good overview of these metrics and how to use them.
- One useful way to think about evaluating forecasts is to consider exploring the scores as a data analysis in its own right. For example, you could look at how the scores change over time, how they change with different forecast horizons, or how they change with different models. This can be a useful way to understand the strengths and weaknesses of your model. Explore some of these aspects using the scores from this session.

# Wrap up
